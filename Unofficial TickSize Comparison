import requests
import time

# Suggested URL Endpoints
SPOT_MARKETS_URL = "https://sentry.lcd.injective.network/injective/exchange/v1beta1/spot/markets"
SPOT_MID_PRICE_URL = "https://sentry.lcd.injective.network/injective/exchange/v1beta1/spot/mid_price_and_tob/"
PERP_MARKETS_URL = "https://sentry.lcd.injective.network/injective/exchange/v1beta1/derivative/markets"

# The asset Decimal counts
ASSET_DECIMALS = {
    "USDT": 6,
    "INJ": 18,
}

# Tick Size Guidelines (Human Readable)
TICK_SIZE_GUIDELINES = {
    "USDT": [
        (0.0000001, 0.0000000001, 1000000),
        (0.000001, 0.000000001, 100000),
        (0.00001, 0.00000001, 10000),
        (0.0001, 0.0000001, 1000),
        (0.001, 0.000001, 100),
        (0.01, 0.00001, 10),
        (0.1, 0.0001, 1),
        (1, 0.001, 0.1),
        (10, 0.01, 0.01),
        (100, 0.01, 0.001),
        (1000, 0.1, 0.0001),
        (10000, 1, 0.0001)
    ],
    "INJ": [
        (0.00000001, 0.00000000001, 100000),
        (0.0000001, 0.0000000001, 10000),
        (0.000001, 0.000000001, 1000),
        (0.00001, 0.00000001, 100),
        (0.0001, 0.0000001, 10),
        (0.001, 0.000001, 1),
        (0.01, 0.00001, 0.1),
        (0.1, 0.0001, 0.01)
    ]
}

def fetch_json(url, retries=3, delay=2):
    #fetch JSON data from a URL, with retries on failure.
    for attempt in range(retries):
        try:
            response = requests.get(url)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"Error fetching data from {url} (Attempt {attempt + 1}): {e}")
            time.sleep(delay)
    return None

def fetch_market_data():
    spot_markets = fetch_json(SPOT_MARKETS_URL)
    
    if spot_markets and isinstance(spot_markets, dict):
        return spot_markets.get('markets', [])
    return []

def process_spot_market_data(markets):
    expected_keys = {
        'ticker', 'base_denom', 'quote_denom',
        'maker_fee_rate', 'taker_fee_rate', 'relayer_fee_share_rate',
        'market_id', 'status', 'min_price_tick_size',
        'min_quantity_tick_size', 'min_notional', 'admin',
        'admin_permissions'
    }
    discrepancies = []
    
    for market in markets:
        missing_keys = expected_keys - market.keys()
        if missing_keys:
            discrepancies.append({
                'market': market.get('ticker'),
                'missing_keys': missing_keys
            })
            continue

    return discrepancies

def process_perpetual_market_data(markets):
    expected_market_keys = {
        'ticker', 'oracle_base', 'oracle_quote', 'oracle_type',
        'oracle_scale_factor', 'quote_denom', 'market_id',
        'initial_margin_ratio', 'maintenance_margin_ratio',
        'maker_fee_rate', 'taker_fee_rate', 'relayer_fee_share_rate',
        'isPerpetual', 'status', 'min_price_tick_size',
        'min_quantity_tick_size', 'min_notional', 'admin',
        'admin_permissions',
    }

    expected_perpetual_info_keys = {
        'hourly_funding_rate_cap', 'hourly_interest_rate',
        'next_funding_timestamp', 'funding_interval',
        'cumulative_funding', 'cumulative_price', 'last_timestamp',
    }

    discrepancies = []

    for market in markets:
        market_data = market.get('market', {})
        perpetual_info = market.get('perpetual_info', {})

        #MAKE SURE ITS A PERPETUAL MARKET
        if not perpetual_info:
            print(f"Market '{market_data.get('ticker')}' is not a perpetual market or missing perpetual_info.")
            continue  

        missing_market_keys = expected_market_keys - market_data.keys()
        if missing_market_keys:
            discrepancies.append({
                'market': market_data.get('ticker', 'Unknown'),
                'missing_keys': missing_market_keys
            })

        missing_perpetual_info_keys = expected_perpetual_info_keys - perpetual_info.keys()
        if missing_perpetual_info_keys:
            discrepancies.append({
                'market': market_data.get('ticker', 'Unknown'),
                'missing_keys': missing_perpetual_info_keys
            })

        # Log Full Data when there be discrepancies!
        if missing_market_keys or missing_perpetual_info_keys:
            print(f"Full market data for {market_data.get('ticker')}: {market}")

    return discrepancies

def convert_to_human_readable(amount, decimals):
    #Converts machine-readable amount to human-readable format, hopefully.
    return amount / (10 ** decimals)

def get_tick_sizes(price, asset_type):
    #SHOULD calculate the suggested tick sizes based on the current price and asset type.
    guidelines = TICK_SIZE_GUIDELINES.get(asset_type, [])
    for min_price, min_price_tick, min_qty_tick in guidelines:
        if price >= min_price:
            return min_price_tick, min_qty_tick
    return None, None

def main():
    spot_markets = fetch_market_data()
    perp_markets = fetch_json(PERP_MARKETS_URL)

    discrepancies = []
    if spot_markets:
        discrepancies += process_spot_market_data(spot_markets)
        
    if perp_markets and 'markets' in perp_markets:
        discrepancies += process_perpetual_market_data(perp_markets['markets'])
    else:
        print("No perpetual markets data returned.")

    if discrepancies:
        print("Discrepancies found:")
        for discrepancy in discrepancies:
            market_name = discrepancy.get('market', 'Unknown')
            missing_keys = discrepancy.get('missing_keys', [])
            print(f"Market: {market_name}, Missing Keys: {missing_keys}")
    else:
        print("No discrepancies detected.")
        
    print("Fetched Perpetual Markets:", perp_markets, "And THAT'S THAT.")

if __name__ == "__main__":
    main()
